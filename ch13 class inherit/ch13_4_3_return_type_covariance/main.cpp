#include <iostream>
#include "./brass.h"
#include "./brassPlus.h"


/**
 *  头文件，分别编译：
    一、C++编译模式
    通常，在一个C++程序中，只包含两类文件——.cpp文件和.h文件。其中，.cpp文件被称作C++源文件，里面放的都是C++的源代码；
    而.h文件则被称作C++头文件，里面放的也是C++的源代码。
    C+ +语言支持“分别编译”（separate compilation）。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的.cpp文件里。.
    cpp文件里的东西都是相对独立的，在编 译（compile）时不需要与其他文件互通，只需要在编译成目标文件后再与其他的目标文件做一次链接（link）就行了。比如，在文件a.cpp中定义 了一个全局函数“void a() {}”，而在文件b.cpp中需要调用这个函数。即使这样，文件a.cpp和文件b.cpp并不需要相互知道对方的存在，而是可以分别地对它们进行编译， 编译成目标文件之后再链接，整个程序就可以运行了。
    这是怎么实现的呢？从写程序的角度来讲，很简单。在文件b.cpp中，在调用 “void a()”函数之前，先声明一下这个函数“void a();”，
    就可以了。这是因为编译器在编译b.cpp的时候会生成一个符号表（symbol table），像“void a()”这样的看不到定义的符号，就会被存放在这个表中。
    再进行链接的时候，编译器就会在别的目标文件中去寻找这个符号的定义。一旦找到了，程序也就可以 顺利地生成了。
    注意这里提到了两个概念，一个是“定义”，一个是“声明”。
    简单地说，“定义”就是把一个符号完完整整地描述出来：它是变 量还是函数，返回什么类型，需要什么参数等等。
    而“声明”则只是声明这个符号的存在，即告诉编译器，这个符号是在其他文件中定义的，我这里先用着，你链接 的时候再到别的地方去找找看它到底是什么吧。定义的时候要按C++语法完整地定义一个符号（变量或者函数），而声明的时候就只需要写出这个符号的原型了。 需要注意的是，一个符号，在整个程序中可以被声明多次，但却要且仅要被定义一次。试想，如果一个符号出现了两种不同的定义，编译器该听谁的？
    二、什么是头文件
    所谓的头文件，其实它的内容跟.cpp文件中的内容是一样的，都是 C++的源代码。但头文件不用被编译。我们把所有的函数声明全部放进一个头文件中，当某一个.cpp源文件需要它们时，它们就可以通过一个宏命令 “#include”包含进这个.cpp文件中，从而把它们的内容合并到.cpp文件中去。当.cpp文件被编译时，这些被包含进去的.h文件的作用便发 挥了。
 */ 

/*
* 虚函数
* 根据引用对象的实际类型确定调用哪个方法。
* 父类引用指向子类对象，调用虚方法后，则调用的是子类的方法
*/

/*
* 如果要在派生类中重写基类方法，通常应该将基类方法定义为virtual的。
*/

/*
* 联编：
* 将函数调用解释为执行特定的函数代码块
* 
* 静态联编(static binding)：
* 非虚方法用静态联编
*
* 动态联编(dynamic binding)：
* 虚函数，具体传入什么类型的引用编译期间并不知道，编译器必须生成能在运行时选择正确的虚方法的代码
* 虚方法用动态联编
*
*/

/*
* 虚函数表 vtbl
* 每个对象有一个隐藏成员，里面保存了一个指向虚函数的地址数组的指针
* 使用虚函数使得对象增大，函数调用时需要额外查询虚函数表地址
*/

/*
* 构造函数不应该是虚函数
* 析构函数应该是虚函数
* 友元不能是虚函数，因为他们不是类成员
*/

/*
* 虚析构函数
* 虚析构函数调用时，也会调用基类的析构函数。
*/

/*
* 重新定义继承的方法，无论参数列表是否相同，基类的同名方法被隐藏
* JAVA里不是这样！！
*/

/*
*
* 返回类型协变
* 在C++中，只要原来的返回类型是指向基类的指针或引用，新的返回类型是指向派生类的指针或引用，覆盖的方法就可以改变返回类型。
* 这样的类型称为协变返回类型（Covariant returns type).
* 覆盖要求函数具有完全相同的入参。

* 一般覆盖具有相同的返回值，否则会提示错误
* 这个规则对返回类型协变而言，则有所放松。覆盖的返回值不区分基类或派生类。从语意上理解，一个派生类也是一个基类。
*/

/*
* 向上强制转换(upcasting):
* 子类的引用或指针转换为父类
*
*向下强制转换(downcasting):
* 父类的引用或指针转换为子类，不允许
*/


int main () {
    {
        Brass dom("Dominic Banker", 11224, 4838.5);
        BrassPlus dot("Dorothy Banker", 12118, 2592.00);

        Brass & b1 = dom;
        Brass & b2 = dot;
        BrassPlus b3("Ik", 12118, 2592.00);

        b1.ViewAcct();
        b2.ViewAcct();
        std::cout << "Test funcion hide:" << std::endl;
        /*
        * 重新定义继承的方法，无论参数列表是否相同，基类的同名方法被隐藏
        */
        //no matching function for call to 'BrassPlus::printName()'
        // b2.printName();
        // b3.printName();
        

        std::cout << "Test normal overwrite now. ....." << std::endl;
        b1.normalOverwrite();
        b2.normalOverwrite();
        b3.normalOverwrite("!");


        /*
        * 重写虚拟函数
        * 返回类型也要相同，返回值如果符合返回类型协变则除外 （静态检查阶段）
        * 如果不是自己本身的类型进行调用（比如父类引用指向子类对象），则参数表必须相同, 否则编译不通过，（静态检查阶段不会去匹配虚函数列表，只检查声明的类型有没有这个方法）
        */

        std::cout << "Test overwrite virtual now. ....." << std::endl;
        b1.specialOverwrite();
        // note: candidate: virtual int Brass::specialOverwrite()
        // b2.specialOverwrite(2); // 声明的类型没这个方法，不进行虚函数查找
        b3.specialOverwrite(3);

        

        std::cout << "Test covariance overwrite virtual now. ....." << std::endl;
        /*
        ** 在C++中，只要原来的返回类型是指向基类的指针或引用，新的返回类型是指向派生类的指针或引用，覆盖的方法就可以改变返回类型。
        * 这样的类型称为协变返回类型（Covariant returns type).
        * 覆盖要求函数具有完全相同的入参。
        * 如果不是自己本身的类型进行调用（比如父类引用指向子类对象），则参数表必须相同, 否则编译不通过，（静态检查阶段不会去匹配虚函数列表，只检查声明的类型有没有这个方法）
        */
        b1.covianceOverwrite();
        // b2.covianceOverwrite(2); // 声明的类型没这个方法，不进行虚函数查找
        b2.covianceOverwrite();
        b3.covianceOverwrite(2);
        std::cout << "main programe end, now desctructor..." << std::endl;
    }
    return 0;
}