#include <iostream>
#include "worker0.h"
#include <string>

const int LIM = 4;


/**
* 指针数组与数组指针
* A) int *p1[10];
* B) int (*p2)[10];
*A: “[]”的优先级比“*”要高。p1 先与“[]”结合，构成一个数组的定义，数组名为p1，int *修饰的是数组的内容，即数组的每个元素。那现在我们清楚，这是一个数组，其包含10 个指向int 类型数据的指针，即指针数组。
*B:  至于p2 就更好理解了，在这里“（）”的优先级比“[]”高，“*”号和p2 构成一个指针的定义，指针变量名为p2，int 修饰的是数组的内容，即数组的每个元素。数组在这里并没有名字，是个匿名数组。
*/

int main () {
    Waiter bob("Bob Apple", 314L, 5);
    Singer bev("Bevely Hills", 522L, 3);


    std::cout << "Test diamond inherit:" << std::endl;

    /*
    * 虚基类：
    * 当在多条继承路径上有一个公共的基类,在这些路径中的某几条汇合处，这个公共的基类就会产生多个实例(或多个副本)，
    * 若只想保存这个基类的一个实例，可以将这个公共基类说明为虚基类。
    * 
    */

    /*
    * 虚继承中最远派生类必须重写虚基类中的虚方法
    */

    /*
    * 派生类的构造函数的成员初始化列表中必须列出对虚基类构造函数的调用；如果未列出，则表示使用该虚基类的缺省构造函数。
    * 显然，虚继承中，虚基类的构造函数只会创建一次，为了防止二义性，因此需要确保手动调用，否则只会调用到虚基类的缺省构造函数，
    * 程序禁止像普通继承那样，调用上一级的构造函数后，再根据上一级构造函数的初始化列表自动调用虚基类的构造函数。
    */

    Singer_Waiter sw("Bob Apple", 314L, 3, 5); // 不同于一般的继承，虚基类的构造函数至多只会调用一次

    /*
    * 可以使用inheritedClassName::Member访问继承的对象的成员
    */
   
    // sw.Set();
    sw.Show();

    Worker *w1 = &sw;
    return 0;
}