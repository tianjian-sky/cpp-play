/*
https://zhuanlan.zhihu.com/p/447663181
*/

/*
深入前置声明
如果你有其他编程语言的经验，会发现c++有点怪异：Java/C#/Python/PHP等语言可以轻松做到循环引用，无需使用类似的前置声明技巧。这不禁让人思考：C++为何必须要用前置声明才能化解？

原因在于C++定义对象有两种方式：一种是A a形式，a即对象，调用成员变量或函数用.，对象在栈中分配；另一种是A* a，a是指针，调用成员变量或函数用->，其指向地址存储实际对象，对象在堆中分配。

分配对象需要知道具体的内存大小，但以下形式我们不能确定类A和类B对象的大小：

class A {
    B b;
}

class B {
    A a;
}



对于这个简单例子，你可以直观认为A和B占用同样的内存，例如1字节，但也可以是2字节，3字节等；根据内存对齐要求，一般是4字节，8字节等。无论哪种情况，编译器无法确定其对象占用内存，便会报错停止编译。所以你应该知道为什么C++永远不应该（不能）这样做了吧？

那为何前置声明加指针的组合能解决循环引用问题的呢？因为正常情况下，数据类型指针在同一机器的编译器里占同样的内存。指针一般是4或者8个字节，对应32和64位指针。用了指针，即使有循环引用，类的大小也能轻易的确定下来。这也是Java/C#/Python/PHP等可以轻松循环引用的原因:这些语言中，对象变量其实都是指针，也意味着对象变量都是引用传递。

如果不移除文件的相互包含，能否省去前置声明呢？答案是不能，原因如下：

1、C++按照一个个编译单元（translation unit）进行编译，如果两个文件互相包含且没有#pragma once等包含保护措施，则会出现递归包含，编译器报错；

2、如果两个头文件都有文件包含保护，编译A时会把B包含进来，但因为B包含了A，A中的包含保护生效，导致B文件内的内容实际未引入A，于是报B为未知符号的错误。

总的来说，不管是否移除对方的头文件，前置声明都是必须的。实践中为了避免文件变动时重新编译的耗费，移除不必要的头文件是一个好习惯。







*/